# JVM垃圾回收机制

> 垃圾收集器需要考虑的核心问题：
>
> 1. 哪些内存需要回收？
>
> 2. 什么时候回收？
>
> 3. 如何回收？

垃圾收集器主要管理的就是 **Java堆**，也包括了方法区中的部分对象回收，主要是常量池的回收和类的卸载。

## 分代收集理论

现代垃圾收集器大部分都是基于**分代收集理论**设计的。以经典分代为例：

- **新生代（Young Generation**）: 包括一个Eden和两个Survivor（From Survivor 和 To Survivor）。
  - 绝大多数对象存活周期都很短，采用**复制算法**收集少量的存活对象即可。

- **老年代（Old Generation）**: 存放存活周期长的对象，采用**标记-清理** 或 **标记-整理算法**
- ~~永久代（Permanent Generation）~~: HotSpot早期方法区，其他虚拟机并不存在, JDK 6准备计划放弃，JDK 7开始实行，JDK 8 时被**元空间（MetaSpace）**替代。

> 为什么要分代存储，可以针对不同的区的特点，设置不同的回收机制。
>
> 例如 新生代往往仅有少量对象存活 采用复制算法收集对象。而老年代中的对象往往存活周期很长，所以采用 标记清除 或者 标记整理收集对象。

### 多种GC事件

| GC                  |                    |                                                              |
| ------------------- | ------------------ | ------------------------------------------------------------ |
| Minor GC / Young GC | 仅对新生代进行GC   | 在进行Minor GC 之前一般会先检查老年代是否存在足够的连续空间存放 新生代的所有对象，不够时 会转为 Full GC。 |
| Major GC / Old GC   | 仅对老年代进行GC   |                                                              |
| Full GC             | 针对整个 堆 进行GC | 收集整个堆和方法区的垃圾                                     |

### 对象分配策略

GC回收时，将Eden区中存活的对象放入Survivor From中，下一次回收时将Survivor From中的对象存入Survivor To中

* **对象优先在Eden分配**：一般情况下，新创建的对象会优先在新生代的Eden区分配。
  * 若Eden区没有足够空间继续进行分配，此时虚拟机会先发起一次 `Minor GC`，尝试回收对象。
* 对于经过Minor GC后依然存活对象，会先尝试放到到 Survivor区 中，同时并且对象的年龄计数 + 1。
  * 每次Minor GC 后 Survivor 中存活的对象 年龄计数都会 + 1。
* Survivor 中中长期存活的对象，会被存放到老年代中。即对象达到一定年龄（不同虚拟机数值不同）
* **大对象直接进入老年代**

> 空间分配担保机制：新生代的空间往往比较小，而老年代的空间比较大，当新生代空间不够分配时，老年代会分配一部分空间给新生代使用。

## 垃圾回收算法

### 标记清除

标记存活对象（不需要的回收的对象），然后将未标记的对象都清除。

* **容易产生大量不连续的内存**，使得大内存对象无法被分配，最终造成内存浪费。

### 标记整理

不同于标记清除的点在于多了一步整理，主要是解决了碎片化内存的问题。

标记存活对象，然后将存活对象向同一端移动，然后清理存活端边界外的对象。

* 效率并不高，不适用于频繁回收的场景。

### 复制

将内存一分为二，每次只使用其中的一块内存，当这块内存不够分配时，就将存活的对象复制到另一块内存中，然后将之前使用的那块内存直接清理。在复制的过程中也解决了内存碎片化的问题。

* 仅使用一半内存，导致内存利用率不高。
* 存活大量对象时，复制操作会很耗费性能。**适用于存活对象周期短，频繁回收的场景，例如新生代。**

### 分代收集

根据对象的存活周期来进行内存划分，再更加不同年代的特点从上述的3个算法中选择合适的。

- 新生代: 采用复制算法。
- 老年代: 标记清除 或者 标记整理。



## 对象存活条件

### 引用计数法

通过给对象添加一个计数器，每有一个地方引用就 加1，引用失效（引用方被回收）时就减1。计数归0就这个对象不存在引用，可以被回收。例如 智能指针`sp(StrongPointer)` 就是引用计数。

不过这种方法存在一个问题，那就是对象间的循环引用问题，两个对象互相引用对方，导致两者都无法被回收。因此主流的虚拟机并没有采用这个算法。

### 可达性分析

定义了一系列 `GC Roots` 对象来作为起点，并将所有有关联的对象进行连接，形成引用链。可达性分析就是分析的对象能否和 GC Roots 之间形成引用链。

* 若一个对象和 GC Roots 之间存在引用链，就表示该对象是当前需要的，就不会被回收。否则表示当前没有被使用，可以被回收。

 `GC Roots` 包括以下几类：

* **虚拟机栈中引用的对象**。栈中的栈帧表示的是当前正在执行的方法，里面的引用就是**当前方法执行需要使用的对象**。
* **本地方法栈中引用的对象**：和虚拟机栈一样，只不过本地方法栈表示的 Native 函数，即 **JNI指针**。
* **静态变量引用的对象**。
* 方法区中的常量引用的对象：即存在于**常量池中的对象**。

![image-20230726154956577](./JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/image-20230726154956577.png)



## 常见的垃圾收集器

> **新生代收集器**（都是复制算法）：Serial、ParNew、Parallel Scavenge
>
> **老年代收集器**：CMS（标记-清理）、Serial Old（标记-整理）、Parallel Old（标记-整理）
>
> **整堆收集器**：G1（一个Region中是标记-清除算法，2个Region之间是复制算法）

**Serial/Serial Old**

> Serial收集器是最基本、发展历史最悠久的收集器。

**特点：**单线程、简单高效(同是单线程时比较)。

**适用场景**：Client模式下的虚拟机。

**ParNew**

是Serial收集器的多线程版本，其他方面基本没有差别。由于是多线程、多CPU，停顿时间比Serial短。

**G1**

## Stop the world

无论使用哪种垃圾收集器，进行垃圾回收时会**先暂停其他所有的工作线程，直至GC结束**。这种现象被称为 发生`Stop the world (STW)`。

---



## 引用类型

#### 强引用（StrongReference）

如果一个对象是强引用, **仅当没有根不可达，时才会被GC回收**，否则永远不会被回收。

#### 软引用（SoftReference）

> 用于内存敏感的高速缓存，例如对于本地常用图片做一层缓存，防止每次读取磁盘。

若一个对象仅具有软引用, 则**当系统内存不足（OOM之前）时会被回收**。

#### 弱引用（WeakReference）

> 比 软引用 更低，只能活到下一次GC。
>
> 常用于需要快速释放防止内存泄露的场景，例如Handler 持有外部的Activity。
>
> ThreadLocal 就是使用的 弱引用来保存数据。

若一个对象仅具有弱引用，则**在发生GC时，无论内存够不够都会被回收**。



#### 虚引用（PhantomReference）

若一个对象仅具有虚引用，则在**任何时候都可能被GC回收**。



---

## 观察GC日志

```shell
# Concurrent----后台回收内存，不暂停用户线程
# Alloc----当app要申请内存，而堆又快满了的时候，会阻塞用户线程

Explicit----调用Systemt.gc()等方法的时候触发，一般不建议使用

NativeAlloc----当native内存有压力的时候触发

Name
Concurrent mark sweep----全部对象的检测回收
Concurrent partial mark sweep----部分的检测回收
Concurrent sticky mark sweep----仅检测上次回收后创建的对象，速度快，卡顿少，比较频繁

```



### 输出GC信息

> 允许时添加 VM options： -XX:+PrintGCDetails

![image-20230711173206777](./JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/image-20230711173206777.png)

运行程序后会输出GC信息。

![image-20230711173241318](./JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/image-20230711173241318.png)
