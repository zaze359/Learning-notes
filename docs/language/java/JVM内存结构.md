# JVM内存结构

JVM内存结构描述的是JVM虚拟机的内部存储结构，它和JMM（Java内存模型是两个不同的概念，JMM是并发编程中的概念）。

![JDK1.8内存结构](./JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/JDK1.8%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.jpg)



## 一、运行时数据区域

### ① 程序计数器

> Program Counter Register 原来你也叫PCR啊🤣。
>
> **线程私有**、**生命周期和线程绑定**。
>
> Java虚拟机规范中**唯一没有规定OOM的区域**。

字节码解释器工作时通过 修改计数器的值 来决定下一条需要执行的字节码指令（分支、循环、跳转、异常处理、线程恢复等）。

* 是一块较小的内存空间。线程结束后，程序计数器也就不再存在，生命周期和线程绑定。

* **每条线程都有一个独立的程序计数器，它记录了线程执行位置**，各线程之间计数器互不影响。从而保证在发生线程切换时每个线程能够恢复到正确的执行位置。

  - 若线程正在执行**Java方法**：计数器值为**当前正在执行的字节码指令地址**。

  - 若线程正在执行**Native方法**：计数器值为**空（Undefinded）**。


### ② 虚拟机栈

> **线程私有**、**生命周期和线程绑定**。
>
> 当创建一个线程时，会在虚拟机中申请一个线程栈。用来保存**方法的局部变量**、**操作数栈**、**动态链接方法**和**返回地址**等信息，并**参与方法的调用和返回**。

Java虚拟机不是真实的物理机，它没有寄存器，所以**指令集是使用Java栈来存储中间数据**。它是为了解决程序运行的问题，考虑如何执行、如何处理数据，描述的是**Java方法执行的线程内存模型**。

* java内存区域当中常说的堆栈中的 **栈** 通常就是指虚拟机栈，更多情况只是指**虚拟机栈中的局部变量表**。
* 服务对象是：Java方法，也就是**字节码**。
* 虚拟机栈由一个个栈帧组成，方法调用就是出栈入栈。

**可能发生的异常：**

* ``StackOverflowError``：线程请求的栈深度大于虚拟机所允许的升深度时抛出。

* ``OutOfMemoryError``
- Java虚拟机栈容量可动态拓展(Classic)：**无法申请足够内存时抛出**。
  
- Java虚拟机栈容量不可动态拓展(HotSpot)：**线程申请栈空间失败时抛出**。


#### 2.1 栈帧

> 每一个**方法被调用直至结束的过程**，就对应一个栈帧在虚拟机栈中`从入栈到出栈的过程`。是一种先进后出的数据结构。
>
> 方法 开始执行 = 栈帧入栈
>
> 方法 执行完毕 = 栈帧出栈	

每个方法被执行的时候，Java虚拟机栈都会同步创建一个**栈帧**(`用于存储方法运行时需要的数据`)。

栈帧中信息主要有: **局部变量表、动态链接、方法出口、操作数栈**。

##### 2.1.1 局部变量表 （Local Variables）

**所需的内存空间在编译期间完成分配**（max_locals）。进入一个方法时，这个方法需要在栈帧中`分配多大的局部变量空间是完全确定的`，且`在方法运行期间不会改变局部变量表的大小`(变量槽Slot的数量)。

一个局部变量槽Slot占32还是64bit是由虚拟机决定的。

一个线程可以将一个基本类型变量的副本传递给另一个线程，但不能共享原始局部变量本身。

| 类型              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| 基本数据类型      | 编译期可知的各种Java虚拟机基本数据类型boolean、byte、 char、 short、 int、 float、 long、 double。 |
| 对象引用          | reference类型不等同于对象本身，可能是指向对象起始地址的引用指针，也可能是代表对象的句柄或其他于此对象相关的位置。 |
| returnAddress类型 | 指向了一条字节码指令的地址。                                 |

> **✨注意点**
>
> 对象`引用存放在栈中的局部变量表中`，具体`对象是存储在堆上`的。
>
> 基础类型并不都是存放在栈中，**方法外定义的全局变量或是成员变量，存放在堆中**。
>
> 包装类是对象所以引用和值是分开存的, 如上一条。即`包装类引用存放在局部变量中，值存储在堆上。`

##### 2.1.2 动态链接

动态链接的作用就是**将常量池中的符号引用转换为在内存地址中的直接引用**。

> 在`.java`文件被编译成`.class`文件时，所有的`变量和方法引用`都作为`符号引用`保存在 Class 文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。Class文件常量池在类加载后存放在方法区中。



##### 2.1.3 方法出口

就是方法的返回地址。

##### 2.1.4 操作数栈

大小也是在编译器确定（max_stacks）。用于存放**方法执行过程中产生的中间计算结果**，包括产生的临时变量。

指令从操作数栈中`取走数据`并将操作后的`结果重新入栈`。

### ③ 本地方法栈

> **线程私有**

本地方法栈类似于虚拟机栈，区别是Java虚拟机栈服务于java方法，**本地方法栈服务于Native方法**。

方法调用时也会创建一个栈帧。

**可能发生的异常：**

* `StackOverflowError`：栈深度溢出时抛出。

- `OutOfMemoryError`：栈扩展失败时抛出。

### ④ 堆（heap）

> **所有线程共享**。
>
> Java堆是``垃圾收集器(Garbage Collected)``所管理的内存区域，'几乎'所有的对象对象实例都在这里分配内存。因为使用逃逸分析技术出现了**栈上分配、标量替换**等优化手段，此时并不是在堆上分配内存。

* 堆会在虚拟机启动时创建，且是虚拟机所管理的最大一块内存，**唯一的目的就是存放对象实例**。处理的是数据的存储问题。
* **堆中存储的是`对象实例`或`数组`**。在应用中创建的对象无论是分配给局部变量，或者是作为另一个对象的成员变量，凡是应用中创建的对象基本都在堆中分配内存。

现代垃圾收集器大部分都是基于分代收集理论设计的。

- 新生代（Young Generation）: 一个 Eden 和两个 Survivor（From Survivor 和 To Survivor）。
- 老年代（Old Generation）:
- ~~永久代（Permanent Generation）~~: HotSpot早期方法区，其他虚拟机并不存在, JDK 6准备计划放弃，JDK 7开始实行，JDK 8 时被元空间替代。
- 元空间（JDK 8后，代替了原先的永久代）

>  逃逸分析（分析对象的作用域）
>
> * 对象只在方法内部使用，则没有发生逃逸。
>
> * 若对象可能被外部引用（传参、返回值），则发生逃逸。
>
> 栈上分配：不会发生逃逸的对象，可能是栈分配，而不是堆分配，随着栈空间一同回收内存。
>
> 标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分或全部可以存放在CPU寄存器中。

---

### ⑤ 方法区（Method Area）

> **线程共享**
>
>  JVM 运行时数据区域的一块**逻辑区域**，《Java虚拟机规范》中只规定了它的概念和作用，所有在不同的JVM上方法区是有区别的。
>
> 这里以``HotSpot``为例介绍。
>
> 虚拟机规范中，是把方法区描述为堆的一个逻辑部分。
>
> ⚠️**字符串常量池**、**静态变量**从JDK7开始被移动到了**堆**中。

* 主要用于存放已被虚拟机加载的**类信息、方法信息、字段信息、常量、即时编译器JIT编译后的代码缓存**等数据，
  * 从JDK7开始开始 **字符串常量池** 和 **静态变量** 被移动到了**堆**中。

* 方法区在无法满足新的内存分配时，将抛出``OutOfMemoryError``异常。

#### 5.1. JDK版本差异(HotSpot)

早期HotSpot使用永久代的方式实现了方法区, 其他虚拟机并不存在永久代这一个概念。元空间和永久代相当于是方法区的不同实现。

##### JDK6及之前版本

此时HotSpot中 方法区=永久代。存储被虚拟机加载的``类型信息``、``常量``、~~``静态变量``~~、~~``字符串常量池``~~、``即时编译器编译后的代码缓存``等数据。

##### JDK7版本

> 主要是整理规划存储内容。

从JDK 7开始弱化永久代，将后续准备不再存放在方法区中的``字符串常量池``和``静态变量``，移动到了``Java堆``中。其他的依然还在永久代中。

##### JDK8及以后版本

> 只是改变了实现方式，存储的内容并没有变, 同JDK7。

JDK 8 时完全废弃了永久代，改用在本地内存中实现的``元空间(Meta-Space)`` 来替代永久代。

废弃原因：

* 为了融合 HotSpot JVM 与 JRockit VM，而JRockit 没有永久代。
* 永久代存在大小上限，空间大小难以确定，导致内存经常不足甚至发生内存溢出（java.lang.OutOfMemoryError: PermGen），而元空间使用本地内存，只受机器的可用内存影响，溢出概率小很多。
* 回收效率低。

#### 5.2. 运行时常量池

运行时常量池类似于传统编程语言中的符号表。

* 运行时常量池具备动态性：除了编译期产生外，运行期间也能将新的常量放入池中。

**Class文件的常量池表**（静态常量池）存放了编译期生成的各种 **字面量** 和 **符号引用** ，这部分内容**将在类加载后存放到方法区的运行时常量池中**。注意为什么又叫静态常量池，静态表明的是编译器间能确定的。`static final String a = new String("a")` 这种并不能确定的就不属于这。

* **字面量：**源代码中的固定值的表示法。包括整数、浮点数和字符串。
* **符号引用：**包括类符号引用、字段符号引用、方法符号引用、接口方法符号。例如String：`java/lang/String`。

> Class文件包含类的版本、字段、方法、接口等描述信息以及常量池表。[Class文件格式、符号引用后续单独补充](./Class文件格式.md)

---

#### 5.3 关于常量池的注意点

> 需要理解和区分`Class文件常量池表`、`运行时常量池`和`字符串常量池`之间的区别。

- **Class文件的常量池表（静态常量池）**： 存放编译期生成的各种字面量和符号引用。
  
  - 在类加载后会存放到方法区的运行时常量池中。
  
- **运行时常量池**
  
  - 具备动态性，运行期间也能将新的常量放入池中。
  
- **字符串常量池**：是JVM 为了优化 字符串（`String` ）而专门开辟的一块区域，避免字符串重复创建。

  - 字符串常量池存放的是 **字符串对象的引用**，是一个哈希表，字符串对象还是存放在在堆上的
  - `String.intern()` 可以动态的将字符串添加到字符串常量池中（字符串不存在时会动态添加一个）。

  ```java
  // 堆："aaaa" 这个字符串对象。
  // 字符串常量池：字符串对象"aaaa"的引用。
  // 栈：a，b 局部变量的引用
  String a = "aaaa";
  // "aaaa" 已存在，直接指向它即可
  String b = "aaaa";
  // a == b：true
  ```



## 二、直接内存

直接内存是一块特殊的内存缓冲区，并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。所以直接内存的分配**不受Java堆大小限制**，**只受设备总内存大小以及处理器寻址空间的限制**。

当各个内存区域和大于物理内存限制时，依然会导致OOM的出现。

> JDK1.4时引入的NIO（Non-Blocking I/O）, 可以使用Native函数库**直接分配堆外内存**，并能通过存储在堆中 **DirectByteBuffer** 对象来操作这部分内存，避免了在Java堆和Native堆中来回复制数据，某些场景能显著提高性能。



## 部分总结

* 栈解决的是程序运行问题，考虑如何执行、如何处理数据。堆处理的是数据的存储。
* 对象**引用存放在栈中的局部变量表中**，具体**对象是存储在堆上**的。
* **基础类型的变量并不都是存放在栈中**。
  * **作为局部变量**: 存储在虚拟机**栈的局部变量表**中。
  * **作为全局变量或是成员变量**：存放在**堆中**。

* 非静态 final 修饰的常量 需要区分是字面量还是对象引用。
  * **字面量常量**：存放在**常量池**中。
  * **引用对象常量**：存放在**堆**中。

* 静态变量从JDK7开始存储到堆中，JDK7之前存储在方法区。
* 包装类是对象所以引用和值是分开存的, 如上一条。即**包装类引用存放在局部变量中，值存储在堆上**。
* static声明的都是属于类。



# 参考资料

> **深入理解Java虚拟机（第3版）**📚
