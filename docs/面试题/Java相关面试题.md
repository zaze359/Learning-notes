# Java相关面试题

## 基础知识

### 如何处理浮点数精度缺失和超过long的整型数值？

精度缺失产生的原因：

由于计算机是使用的二进制运算，而计算机在表示一个数字是位数是有限的，所以在处理无限循环的小数时只能截断，导致精度丢失。

由于精度缺失问题在《阿里巴巴Java开发手册》中提到：**浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用 equals 来判断**。

处理方式：

* 使用`BitInteger`处理超过long的数据：内部是使用`int[]`数组来存储任意大小的整型数据，`BigDecimal.valueOf(double val)`存在精度损失风险。

* 使用`BigDecimal`处理浮点数精度丢失问题：推荐使用`BigDecimal(String val)`。

---

### Java和C++的区别

相同点：

* 都是面向对象语言，支持封装、继承和多态。

不同点：

* Java是单继承不支持多继承，C++支持多继承。
* C++提供了指针操作，可以直接访问内存，Java不能。
* Java有垃圾回收机制，自动管理内存，C++需要自己管理。
* C++支持方法重载和操作符重载，Java只支持方法重载。

---

### 自增自减运算符

> `++`、`--`
>
> 注意运算符的位置而导致的差异

运算符在变量后（先赋值后运算）：

```java
b = 1;
// 先赋值后计算
a = b++;
// a = 1;
// b = 2;
```

运算符在变量前（先运算后赋值）：

```java
b = 1;
// 先自增 在赋值
a = ++b;
// a = 2;
// b = 2;
```

---

### 基础类型和包装类型的区别

* 默认值：包装类型的默认值是null, 基础类型的默认值是具体的某个值。
* 泛型：包装类型可用于泛型，基础类型则不行。
* 内存存储位置：包装类属于对象类型，对象实例存储在堆中。基础类型作为局部变量存储在虚拟机栈的局部变量表中。
* 内存占用：基础类型占用空间更小。
* 比较方式：基础类型直接值比较，包装类型则时`equals`比较，值相同，对象不一定相同。

---

### 接口和抽象类的区别

共同点：

* 两者都不能被实例化。
* 都可以有默认实现。Java 8 之后可以使用`default`定义接口的默认实现。
* 都有抽象方法。

不同点：

* Java中一个类无法多继承，所以只能继承一个抽象类，但是可以实现多个接口。
* 目的不同：抽象类强调的是代码复用，接口强调的是约束规范。
* 成员变量访问权限不同：接口一定是`public static final`的必须初始化赋值不可修改。抽象类则是和普通的类相同，默认为`default`，不一定需要初始化赋值，可修改。



---

### 面向对象和面向的区别

* 面向过程：将问题拆解为一个个方法，然后一步步调用方法解决问题。

* 面向对象：先对问题进行抽象，抽象出一个对象。然后通过操作对象来解决问题。更加清晰，易维护。



---

### JDK & JVM & JRE 的区别和联系

**JVM是Java虚拟机**（例如HotSpot），针对不同的系统有特定的实现，但是上面运行的是相同的字节码，是Java实现跨平台的关键`Compile Once,Run AnyWhere`。

**JRE是Java运行时环境**，包含了JVM和一些标准类库，可以在上面运行Java程序。

**JDK是Java软件开发工具包**，包含了JRE和一些开发工具集（javac等）。涉及到编译都需要安装JDK（如JSP）。

三者是包含关系：JDK > JRE > JVM

* JDK = JRE + 开发工具集

* JRE = JVM + Java标准类库

---

### Java是解释执行吗？

> **Java 是编译与解释共存的语言**。

​	Java会先通过 `javac` 将 `.java 文件` 编译成`.class文件`。在运行时Java虚拟机内嵌的解释器会逐条读入，逐条**解释运行**，这也是Java实现跨平台的原因。

​	同时Java虚拟机也提供了JIT编译器，能在运行时将**热点代码(字节码)直接编译成机器码**，此时这些热点代码就属于编译执行。

---



## JVM相关

### 什么是字节码

即`.class`文件,是可以被JVM理解处理的代码。它不面向任何特定的处理器，仅面向虚拟机。它被类加载器加载，解释或编译执行。

* 字节码保留了解释型语言可移植的特性。
* 优化了解释型语言执行效率低的问题（相对C++、Go等还有一定差距）。

### JVM的内存结构是什么样子的

JVM 内存结构主要包括:

* **程序计数器**：线程私有，用于保存当前线程所执行的字节码行号。用于流程控制和状态恢复。
* **堆**：线程共享，存放的是具体的对象实例、数组，另外还包括静态变量、字符串常量池。
* **虚拟机栈**：线程私有，由一个个栈帧组成，每次java方法调用就是 栈帧出栈入栈的过程。
* **本地方法栈**：线程私有，服务于Native方法的调用，每次j方法调用也是栈帧出栈入栈的过程。
* **方法区&元空间**：使用本地内存实现，存储主要包括 类信息、常量、JIT即时编译后的代码缓存、运行时常量池等。
* **直接内存**：位于本地内存中，可以调用Native函数直接在推外分配内存。



### 类加载机制了解吗？

虚拟机启动时**标明的启动类**，也就是应用程序的入口 main() 函数所在的类会先被加载。同时当我们通过 **new一个对象**、**调用类的静态变量或者方法**会触发类加载机制。**子类加载时会使父类也被加载**。

主要分为3个阶段：

* 加载：使用类加载器ClassLoader加载class字节码到内存中。会在堆中生成一个class类对象，加载的类数据保存在方法区中。
* 连接
* 初始化



### Java 实例的初始化顺序（成员变量、静态变量、构造函数等）分别是怎样的？



### DexClassLoader与PathClassLoader的区别？



### 字符串常量池相关问题

> 字符串常量池 是 JVM 为了提升性能和减少内存消耗针对String专门开辟的一块区域，主要**目的是为了避免字符串的重复创建**。

**String a = new String("aaa"); 创建了多少个字符串对象？**

答案是：1个或2个字符串对象。

首先由于`new String()`会先在堆上创建一个字符串对象。

若字符串常量池中存在字符串`aaa`的引用，则这个`new String对象`赋值为字符串`aaa`的引用。此时仅创建一个字符串对象。

若字符串常量池中不存在字符串`aaa`的引用，则需要创建一个String对象`aaa`同时将它的引用存放到常量池中。最后再为这个`new String对象`赋值为字符串`aaa`的引用。此时仅创建两个字符串对象。



### JVM性能调优概述

基本原则：

- 虚拟机内部已存在许多的优化保证能够稳定使用，当已经出现或者将会出现时再考虑优化。
- 上线前，考虑将JVM参数设置调整到适合当前需求。
- GC优化是最后手段，应优先考虑优化项目的代码和架构，项目实在没有多少优化空间时再考虑优化GC。
- GC内存最大化原则：处理吞吐量和延迟问题时根据实际调整, 能使用的内存越大(java堆越大)，垃圾收集效果越好。
- GC调优3选2原则：吞吐量、延迟、内存中选择2个进行调优。

调优场景：

- Heap内存（老年代）持续上涨达到设置的最大内存值。

- 发生内存异常

  ```
  OutOfMemory
  OutOfDirectMemoryError
  ```

- 应用使用了本地缓存且占用大量内存空间。

- 应用的CPU或内存占用过高不下。

- 系统的吞吐量和响应性能不高或下降。

- 监控GC情况

  ```
  - FullGC是否过于频繁。最大持续时间。
  - MinorGC持续时间、次数
  - GC停顿（Stop The World）太长，例如超过1秒。
  ```

排查流程：

- CPU占用过高场景

  ```shell
  # 1. 查询CPU占用最高的进程的pid，例如：12345
  top
  # 2. 然后查询该进程下占用最高的线程id,例如 6789
  top -H -p 12345
  # 3. 将线程ID转换为16进制(java native线程已16进制输出)
  printf '%x\n' 6789
  # 4. 打印java线程调用栈信息，定位问题
  jstack 12345 | grep '0x1a85' -A 50 --color
  ```

- 内存占用过高场景

  ```shell
  # 1. 查询内存占用最高的进程的pid，例如：12345
  top -d 2 -c
  # 2. 查看JVM堆内存分配情况
  jmap -heap 12345
  # 3. 查看占用内存比较多的对象
  jmap -histo 12345 | head -n 100
  # 4. 查看占用内存比较多的存活对象
  jmap -histo:live 12345 | head -n 100
  ```




### Jvm的垃圾回收机制是什么样子的？

###  JVM有哪些垃圾回收器

> **新生代收集器**（都是复制算法）：Serial、ParNew、Parallel Scavenge
>
> **老年代收集器**：CMS（标记-清理）、Serial Old（标记-整理）、Parallel Old（标记-整理）
>
> **整堆收集器**：G1（一个Region中是标记-清除算法，2个Region之间是复制算法）

**1. Serial/Serial Old收集器**

> Serial收集器是最基本、发展历史最悠久的收集器。

**特点：**单线程、简单高效(同是单线程时比较)。进行垃圾回收时必须暂停其他所有的工作线程，直至它结束(STW)。

**适用场景**：Client模式下的虚拟机。

**2. ParNew收集器**

> ParNew其实是Serial收集器的多线程版本。

---

## 线程相关

### synchronized 关键字修饰静态方法和非静态方法的区别？

区别：

* 修饰静态方法：锁的是 `类.class`，这个**类对象**。
* 修饰非静态方法：锁的时 具体的**类实例**。

一个类中有一个静态方法 A 和非静态方法 B，都被 synchronized 修饰。两个线程分别去调用同一个实例的方法 A 和方法 B，会产生竞争吗？ 

**不会**

由于锁的不是同一个对象，所以两个线程可以同时分别访问 都被synchronized修饰的静态方法和非静态方法，不会发生竞争。

### volatile 关键字的作用？

volatile 相比 synchronized、Lock更加轻量级，常在双重检测中配合synchronized 一起使用。

* **内存可见性**：直接从主存存取这个变量，修改后会立即保存到主存中。
* **禁止指令重排**：保证有序性。只要是为了避免 非原子操作的并发问题。例如对象的创建过程。
  * volatile 的重排规则是：若一个线程先去写，另一个线程去读，则一定时写入完成后 才能读取。
* **volatile 无法保证原子性**。所以双重检测时需要配合 synchronized  一起使用


解释一下“立即对所有线程可见”和“禁止指令重排”？

* 立即对所有线程可见：总是能读取到最新值，是**直接从主存存取这个变量**。
  * 在java的内存模型中，每个线程拥有自己的工作内存（栈 和 寄存器）。线程启动时会从主存中将变量加载到工作内存，操作结束后再同步回主内存中。由于这个模式从而产生了常见的并发问题。
* 禁止指令重排：Java允许编译进行指令重排， 当语句之间不存在关联时，它们的执行顺序不一定就是我们代码的编写顺序，这在多线程中可能发生问题。禁用编译器的重排，也是为了防止出现常见的并发问题。

### 在双重检测中为什么要禁止指令重排？

**禁止指令重排的目的**：主要是由于 单例对象在实例化过程中并不是一个原子操作，`singleton = new Singleton()`分为三个步骤：

1. 给singleton对象分配内存。此时singleton依然是 null
2. 调用构造函数初始化。
3. 将singleton指向分配的内存空间地址，这样才使得 singleton != null。

而 2、3 两个步骤顺序即使颠倒 也不会影响 最终的结果，所以可能发生指令重排，**导致 singleton 先指向内存空间的地址，但是此时还没有调用构造函数进行初始化**。若恰好发生了并发，另一个线程在双重检测的第一次不加锁检测中发现 `singleton != null`，然后直接返回并使用的这个还未初始化的对象，那么就会由于没有初始化而出错。

**内存可见性**：主要是由于Java内存模型引起的，线程会从主存中同步内存到本地内存，正常情况都是读写的线程本地内存，然后再同步到主存中，这就会在多线程并发中出现不同线程中内存同步的问题。而这个可见性的作用就是 直接读写主内存。同时volatile 还保证 写在读之前。

volatile 并不能保证原子性，所以在双重检测中还需要**加锁保证原子性**。



### Daemon线程和User线程的区别？

**User线程**：

`new Thread`默认创建的就是User线程。没有User线程 JVM就会退出。

```java
Thread threadA = new Thread(new Runnable(){...});
threadA.start();
```

**Daemon线程**：

需要 通过 `thread.setDaemon(true)` 将线程设置为 守护线程。用于实现一些和主流程无关，但是比较重要任务。

```java
Thread threadA = new Thread(new Runnable(){...});
// 设置为Daemon线程，需要在start之前调用。
threadA.setDaemon(true);
threadA.start();

// 可以通过 threadA.isDaemon()判断。
```

**User 线程 和 Daemon 线程的差异**：

当JVM中所有的User线程退出后，所有的Daemon线程也会马上退出执行，并且JVM进程也会退出。
* JVM进程退出的条件是：不存在User线程。所以即使还存在守护线程，但是没有User线程时虚拟机也依然会直接退出。
* main函数所在线程的退出，不影响其他User线程的运行，也不影响JVM进程是否退出。

### 多线程有哪几种创建方式？

1. 直接通过 ``new Thread()`` 创建多个线程，存在管理的问题。
2. 通过线程池来创建线程




### 阿里编程规范为什么不建议使用Executors创建线程池？

最主要原因就是通过 Executors 创建的线程池，它的阻塞队列一般都是没有限制大小的，理论上能无限添加，永远不会触发拒绝策略，可能导致内存爆炸。况且直接通过 `ThreadPollExecutor` 创建线程池也并不复杂。

例如  `newFixedThreadPool` 和 `newSingleThreadPool` 使用的是无界队列 ``new LinkedBlockingQueue<Runnable>()``。



### TLS

#### 什么是TLS？

TLS 就是 **线程局部变量存储空间**。它是每个线程所私有的一块存储空间，这块空间线程间是不共享的。

它以 `kv`的格式来存储在线程内部使用的全局变量，这样**可以避免多线程访问的数据竞争**。TLS 在Java、C++ 都中都有对应的实现，它将数据和线程关联起来，提供了一个全局的索引表存储线程局部数据的地址。

#### 为什么要用TLS?

主要是因为在Linux的进程和线程模型中，同一个进程内的多个线程共享进程的地址空间，因此不同线程间共享一个全局变量和静态变量。所以一个线程修改后也会影响到其他线程，并且使用全局变量并且为了保证安全，往往需要锁来控制，成本也比较高。

但是一个模块中我们可能会需要一些全局变量来存储数据，但是又不希望线程之间互相影响，基于这个场景操作系统就提供了 TLS 机制。

#### ThreadLocal 

[ThreadLocal分析](../language/java/ThreadLocal.md)

#### ThreadLocal 有哪些内存泄漏问题

内存泄露问题 主要是由于 我们 ThreadLocalMap的存储单位 `ThreadLocalMap.Entity` 导致的。

* **key：ThreadLocal<?>是弱引用关系。**
* **value：实质是一个强引用关系**。 

所以当这个线程没有销毁时，就会出现泄漏问题，value无法被回收。特别是使用线程池时，由于线程复用，这个泄露现象更容易发生。

如何处理：我们可以显示调用``ThreadLocal.remove()`` 来将 value移除。

```java
static class Entry extends WeakReference<ThreadLocal<?>> {
    // 注意这个 value 是强引用
    Object value;
    Entry(ThreadLocal<?> k, Object v) {
        // 这里传入的 key 是弱引用
        super(k);
        // 强
        value = v;
    }
}
```



---

## 动态代理

> 主要考察反射机制。
>
> 动态代理解决了什么问题。





### JDK动态代理为什么设计成只支持接口 ?

在使用 JDK动态代理时，会生成一个继承了 Proxy的增强代理类，但是由于 Java只支持单继承，所以只能它能继续实现接口，但是无法再继承类。
