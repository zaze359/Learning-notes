# Kotlin相关面试题

## Kotlin 和 Java 的 异同

| 异同点   | kotlin                                                  | java                                  |
| -------- | ------------------------------------------------------- | ------------------------------------- |
| 可见性   | 默认为public                                            | 默认为Default                         |
| 继承权限 | 默认不可继承，必须使用 `open`关键字修饰后才能继承、重写 | 默认开放继承、且允许重写              |
| 多继承   | 接口可以有默认实现，所以能通过接口的方式实现多继承。    | 不支持，不过java8后接口也支持默认实现 |
|          |                                                         |                                       |

### kotlin 相比 Java 有哪些优点

* Kotlin 的 object 关键字 可以方便的实现 单例模式。
* Kotlin的伴生对象可以帮助我们将静态方法、变量清晰的分割开来。
* Kotlin的密封类、密封接口 拥有枚举类的逻辑完备性的同时，还允许拥有多个实例，而枚举只有一个实例
* Kotlin的内部类默认为 `static`，可以避免非静态内部类持有外部引用可能导致的泄漏问题。而Java 需要我们自己声明static，容易不小心出现错误。
* Kotlin 的委托 能够方便的实现代理模式，同时也能利用委托实现类似多继承的功能。
* Kotlin 的扩展，允许我们方便的添加额外需求的功能，可以将之前在Java中的工具类 都有扩展的方式来实现。同时对于类来说可以更加关注核心功能，非核心功能也可以由扩展实现。最最关键的是 可以对三方类进行扩展，大大提高了灵活性。
  * 扩展的本质实际就是静态方法
* Kotlin的空安全：kotlin的类型系统帮我们有效的避免了访问空引用对象的问题，可以通过IDEA的语法检测工具就检测到可能为空的场景，同时不处理就无法通过编，除非是使用了 `!!` 强行认为不会为空。不过和Java混用时 kotlin 空安全机制会失效，除非Java代码中使用注解明确说明是否可空。
  * kotlin 调用 Java，除非注解明确说明是否可空，否则kotlin 空安全机制会失效，java可返回空，kotlin也允许通过编译。
  * java 调用 kotlin，即使kotlin的参数不允许空，java调用时也能够传入空。

### Kotlin 中的 object 相当于 Java 中的哪一种单例模式？

object 的单例模式是以静态代码块的方式实现的，利用了类的初始化锁来保证线程安全。

### Kotlin 中的可见性和 Java 是不一样的，分别讲讲？

java：

* 默认是default，仅同包下可见。
* protected：同包级别以及子类可见。
* private：私有，仅类内可见。
* public：所有可见。

Kotlin：

* 默认是public：所有可见。
* private：私有，仅类内可见。若是顶层函数，则是在同文件下可见，
* protected：类内以及子类可见。注意kotlin的protected不是包内可见的，这点和java不同。
* internal：模块内可见，常用于封装SDK时。kotlin没有了包内可见的概念，增加了模块内可见的概念

## Kotlin多继承的实现方式

* 利用接口允许提供默认实现的特性，继承多个接口来实现。
  * 多继承问题：重写这个函数 使用 `super` 关键字指定 使用哪个父类方法。
* 利用委托。
  * 多继承问题：重写这个函数 指定代理到哪个对象。

## Kotlin 的 lazy 关键字

一般会和委托 `by` 一起使用，也就是常见的 `by lazy` 懒加载。它的内部实现是一种单例模式，值被初始化后就不会再修改。

它有三种加载模式：

* `LazyThreadSafetyMode.SYNCHRONIZED`：互斥锁，内部会加锁保证仅有一个线程执行初始化函数进行初始化，发生并发时其他线程需要等待。
* `LazyThreadSafetyMode.PUBLICATION`：利用的CAS机制，发生并发时只要当前值还没有被初始化就都能执行初始化函数，初始化的值是第一个返回的值。
* `LazyThreadSafetyMode.NONE`：不加锁，所以并发时不保证结果。

## 协程

[Kotlin协程](../language/kotlin/Kotlin协程.md)

### 介绍一下协程?

协程是一种**为异步程序设计的程序控制流程的机制**。其核心点是**挂起和恢复**，并且这个**流程是由程序逻辑自己控制的**，而不是像线程那样调度时间是由操作系统控制的。

### 讲一个协程的scope与context?

**协程的上下文**：负责管理执行环境的通用数据资源，同时提供一些管理协程的能力。常见的上下文有 `EmptyCoroutineContext`、`Job`、`Dispatcher`、`ContinuationInterceptor` 、`CoroutineName` 等。

* 协程上下文的结构类似 `List`、`Map`， 内部存储为一个左向链表，节点一般为 `CombinedContext`。
* 可以通过 `+` 进行 Element 的合并。
* 可以通过设置不同的 Context 来指定不同的工作线程。如 `Dispatcher.IO` 等



**协程的作用域**：

协程的作用域 实际上就是对于CoroutineContext 的封装，一般来说Scope中的功能都是通过扩展函数的方式提供的，我们能够通过这些扩展的函数对方便的协程进行控制。同时它也可以约束上下文的作用范围，在这个作用域下我们使用的都是同一个上下文。

* 约束挂起函数的调用位置以及扩展协程体功能：一般会通过扩展函数的方式来扩展功能，同时只有在作用域下才能调用这些函数。
* 约束以及传递CoroutineContext：在相同作用域下我们操作的是同一个上下文，同时也避免了不同作用域间的context相互影响。

常见的 Scope有：ViewModelScope、GlobalScope、所有AbstractCoroutine子类等。

